#!/usr/bin/env python
import rospy
import shapely
import smach
import smach_ros
from smach_ros import ServiceState
from smach import Iterator, CBState
import math
from shapely import geometry
import signal
import time
from nav_msgs.msg import Path
from std_msgs.msg import Bool, String, Int16
from vitulus_msgs.msg import PlannerProgram, Mower, Device_icon_status
from mbf_msgs.msg import ExePathAction
from mbf_msgs.msg import GetPathAction
from rtabmap_msgs.msg import Info
from mbf_msgs.msg import RecoveryAction
from mbf_msgs.srv import CheckPath, CheckPathRequest, CheckPathResponse
import PyKDL as kdl
from geometry_msgs.msg import Pose, Point, Quaternion, PoseStamped, PoseArray, PoseWithCovarianceStamped
import actionlib
import mbf_msgs.msg as mbf_msgs
import sys


class GetZoneData(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['available', 'failed', 'preempted'],
                             input_keys=['program', 'zone_cut_height', 'zone_rpm', 'index', 'zone_name',
                                         'zone_start_pose', 'paths'],
                             output_keys=['zone_cut_height', 'zone_rpm', 'zone_name', 'zone_start_pose', 'paths', 'controller'])

    def execute(self, userdata):
        rospy.loginfo('[{}]Getting zone data - state GET_ZONE_DATA'.format(rospy.get_caller_id()))
        userdata.zone_cut_height = userdata.program.zone_list[userdata.index].cut_height
        userdata.zone_rpm = userdata.program.zone_list[userdata.index].rpm
        userdata.zone_name = userdata.program.zone_list[userdata.index].name
        userdata.zone_start_pose = userdata.program.zone_list[userdata.index].paths[0].poses[0]
        userdata.paths = userdata.program.zone_list[userdata.index].paths
        userdata.controller = 'base_local_planner/TrajectoryPlannerROS'
        print(userdata.zone_name)
        # print(userdata.zone_cut_height)
        show_map_planner_pub = rospy.Publisher("/web_plan/show_map_layer", String, latch=True, queue_size=1)
        show_map_planner_pub.publish(String("SMACH|MAP|FULL"))
        rospy.sleep(3)

        if self.preempt_requested():
            self.service_preempt()

            return 'preempted'
        return 'available'


class GetPathData(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['available', 'preempted'],
                             input_keys=['program', 'zone_cut_height', 'zone_rpm', 'index', 'zone_name', 'path_planner',
                                         'zone_start_pose', 'path_plan', 'index_path', 'paths', 'path_start_pose',
                                         'path', 'final_pose'],
                             output_keys=['zone_cut_height', 'zone_rpm', 'zone_name', 'zone_start_pose', 'path_planner',
                                          'path_plan', 'paths', 'path_start_pose', 'path', 'final_pose'])
    def path_to_polygon(self, path):
        # create shapely polygon from path poses
        polygon = geometry.LinearRing([[pose.pose.position.x, pose.pose.position.y] for pose in path.poses])
        polygon = shapely.remove_repeated_points(polygon)
        return polygon

    def path_to_multiline(self, path):
        # create shapely multiline string from path poses
        multiline = geometry.MultiLineString(
            [[[pose.pose.position.x, pose.pose.position.y] for pose in path.poses]])
        return multiline

    def path_to_line(self, path):
        # create shapely multiline string from path poses
        line = geometry.LineString(
            [[pose.pose.position.x, pose.pose.position.y] for pose in path.poses])
        return line

    def direction(self, line):
        # point_2.x - point_1.x, point_2.y - point_1.y)
        x = line[1][0] - line[0][0]
        y = line[1][1] - line[0][1]
        diagonal = math.sqrt(x ** 2 + y ** 2)
        if y < 0:
            if x >= 0:
                angle = math.asin(y / diagonal)
            else:
                angle = math.acos(x / diagonal) * -1
        else:
            if x >= 0:
                angle = math.asin(y / diagonal)
            else:
                angle = math.acos(x / diagonal)
        return angle

    def execute(self, userdata):
        rospy.loginfo('[{}]Getting path data - state GET_PATH_DATA'.format(rospy.get_caller_id()))
        path = userdata.paths[userdata.index_path]
        userdata.path_planner = path
        userdata.path_start_pose = path.poses[0]
        show_map_planner_pub = rospy.Publisher("/web_plan/show_map_layer", String, latch=True, queue_size=1)
        show_map_planner_pub.publish(String("SMACH|ZONE|{}".format(userdata.zone_name)))
        line = geometry.LineString([[path.poses[0].pose.position.x, path.poses[0].pose.position.y],
                                    [path.poses[-1].pose.position.x, path.poses[-1].pose.position.y]])

        # print("Line length: {}".format(line.length))
        segmentize_distance = 0.03
        if line.length == 0:
            print("Outline path")
            start_offset = 0.18
            start_poses_offset = int(round(start_offset / segmentize_distance))
            path_new = Path()
            path_new.header = path.header
            polygon = self.path_to_polygon(path)
            for n in range(0, len(polygon.coords) - 1):
                line = geometry.LineString([[polygon.coords[n][0], polygon.coords[n][1]],
                                            [polygon.coords[n + 1][0], polygon.coords[n + 1][1]]])
                angle = self.direction(line.coords)
                line = line.segmentize(segmentize_distance)
                for point in line.coords:
                    pose = PoseStamped()
                    pose.header.frame_id = "map"
                    pose.header.stamp = rospy.Time.now()
                    pose.pose.position.x = point[0]
                    pose.pose.position.y = point[1]
                    pose.pose.position.z = 0.0
                    pose.pose.orientation = Quaternion(
                        *(kdl.Rotation.RPY(0, 0, angle).GetQuaternion()))
                    path_new.poses.append(pose)
            path_new.poses = path_new.poses[0:-start_poses_offset]
            path_new.poses = path_new.poses[start_poses_offset:]
            path = path_new
            userdata.path_start_pose = path.poses[0]
            userdata.final_pose = path.poses[-1]

        else:
            print("Coverage path")
            line = self.path_to_line(path)
            path_new = Path()
            path_new.header.frame_id = "map"
            path_new.header.stamp = rospy.Time.now()

            line = line.segmentize(segmentize_distance)
            for pose_id in range(0, len(line.coords) - 1):
                angle = self.direction([[line.coords[pose_id][0], line.coords[pose_id][1]],
                                       [line.coords[pose_id + 1][0], line.coords[pose_id + 1][1]]])
                pose = PoseStamped()
                pose.header.frame_id = "map"
                pose.header.stamp = rospy.Time.now()
                pose.pose.position.x = line.coords[pose_id][0]
                pose.pose.position.y = line.coords[pose_id][1]
                pose.pose.position.z = 0.0
                pose.pose.orientation = Quaternion(
                    *(kdl.Rotation.RPY(0, 0, angle).GetQuaternion()))
                path_new.poses.append(pose)
            path = path_new

        # publish current path
        pub_current_path = rospy.Publisher('/test_path', Path, latch=True, queue_size=1)
        pub_current_path.publish(path)
        userdata.path = path

        if self.preempt_requested():
            self.service_preempt()
            return 'preempted'
        return 'available'


class CheckDistance(smach.State):
    def __init__(self):
        smach.State.__init__(self, outcomes=['on_place', 'exe_path', 'preempted'],
                             input_keys=['path_cost'],
                             output_keys=['path_cost'])

    def execute(self, userdata):
        rospy.loginfo('[{}]Checking path distance - state CHECK_DISTANCE'.format(rospy.get_caller_id()))
        # print("Path distance: {}".format(userdata.path_cost))
        if self.preempt_requested():
            self.service_preempt()
            return 'preempted'
        if userdata.path_cost <= 0.2:
            return 'on_place'
        else:
            return 'exe_path'


def wait_for_mbf():
    client = actionlib.SimpleActionClient("/move_base_flex/move_base", mbf_msgs.MoveBaseAction)
    available = client.wait_for_server(rospy.Duration(30))
    if not available:
        rospy.logwarn("Move Base Flex is not available")
    else:
        rospy.loginfo("Move Base Flex is ready")
    return available


def main():
    rospy.init_node('mower_unit_smach')
    pub_smach_status = rospy.Publisher('/mower_smach/status', String, latch=True, queue_size=1)
    pub_log_info = rospy.Publisher('/nextion/log_info', String, queue_size=10, latch=True)
    pub_active_prg = rospy.Publisher('/mower_smach/active_program', String, latch=True, queue_size=1)
    pub_pm_play_melody = rospy.Publisher('/pm/play_melody', Int16, queue_size=10)
    rospy.Publisher("/web_plan/program_new", PlannerProgram, queue_size=1)
    pub_active_prg.publish(String(" "))
    wait_for_mbf()
    # Create SMACH state machine
    sm = smach.StateMachine(outcomes=['succeeded', 'aborted', 'preempted'])

    # Define userdata
    sm.userdata.path_plan = None
    sm.userdata.path = None
    sm.userdata.path_planner = None
    sm.userdata.path_start_pose = None
    sm.userdata.program = None
    sm.userdata.zone_cut_height = None
    sm.userdata.zone_rpm = None
    sm.userdata.zone_name = None
    sm.userdata.zone_start_pose = None
    sm.userdata.paths = None
    sm.userdata.path_cost = None
    sm.userdata.final_pose = None
    sm.userdata.prg_start_time = None

    pub_smach_status.publish(String("Ready"))


    with sm:
        # Program callback for state WAIT_FOR_PROGRAM
        def callback_program(userdata, msg):
            userdata.program = msg
            rospy.loginfo('[{}]Get new program to run - state WAIT_FOR_PROGRAM'.format(rospy.get_caller_id()))
            pub_active_program = rospy.Publisher('/mower_smach/active_program', String, latch=True, queue_size=1)
            pub_active_program.publish(String(msg.name))
            pub_log_info.publish(String("Executing program: {}".format(msg.name)))
            pub_pm_play_melody.publish(Int16(2))  # 5:short_beep, 1:beep, 2:double beep,
            pub_smach_status.publish(String("Initiating"))
            rospy.sleep(1.0)
            userdata.prg_start_time = rospy.Time.now()
            if sm.preempt_requested():
                sm.service_preempt()
                return 'preempted'
            return False

        # Monitor topic to get program
        smach.StateMachine.add('WAIT_FOR_PROGRAM', smach_ros.MonitorState('/web_plan/program_active', PlannerProgram,
                callback_program, output_keys=['program', 'prg_start_time'], input_keys=['program']
            ),
            transitions={
                'invalid': 'LOAD_MAP',
                # 'invalid': 'ZONE_IT',
                'valid': 'WAIT_FOR_PROGRAM',
                'preempted': 'PREEMPTED_STOP'
            }
        )

        ########################################  LOAD MAP  ########################################
        # Load desired map running by program
        # Add state LOAD_MAP
        @smach.cb_interface(input_keys=['program'], output_keys=[], outcomes=['success_indoor', 'success_outdoor', 'failure', 'preempted'])
        def set_map_cb(userdata):
            rospy.loginfo('[{}]Setting the map - state LOAD_MAP'.format(rospy.get_caller_id()))
            indoor = False
            if userdata.program.map_name.split('***env*')[1] == 'INDOOR':
                pub = rospy.Publisher('/navi_manager/load_map_rtabmap', String, latch=True, queue_size=1)
                indoor = True
            else:
                pub = rospy.Publisher('/navi_manager/load_map', String, latch=True, queue_size=1)
            msg = String()
            msg.data = userdata.program.map_name
            pub_status = pub.publish(msg)
            pub_log_info.publish(String("Loading the map"))
            pub_smach_status.publish(String("Loading map"))
            rospy.sleep(4.0)

            if sm.preempt_requested():
                sm.service_preempt()
                return 'preempted'

            if pub_status is None:
                if indoor:
                    return 'success_indoor'
                else:
                    return 'success_outdoor'
            else:
                return 'failure'

        smach.StateMachine.add('LOAD_MAP', CBState(set_map_cb),
                               {'success_indoor': 'WAIT_FOR_RTABMAP',
                                'success_outdoor': 'WAIT_FOR_GPS_FIX',
                                'failure': 'WAIT_FOR_PROGRAM',
                                'preempted': 'PREEMPTED_STOP'})

        ########################################  RTABMAP  ########################################
        # Program callback rtabmap ready
        def callback_rtabmap_status(userdata, msg):
            # print("rtabmap status: {}".format(msg))
            if sm.preempt_requested():
                sm.service_preempt()
                # sm.recall_preempt()
                return 'preempted'
            if msg.proximityDetectionId > 0:
                pub_log_info.publish(String("Rtabmap is ready"))
                pub_pm_play_melody.publish(Int16(1))  # 5:short_beep, 1:beep, 2:double beep,
                pub_smach_status.publish(String("Rtabmap ready"))
                rospy.sleep(0.5)
                return False
            else:
                return True

        # Add state WAIT_FOR_RTABMAP
        smach.StateMachine.add('WAIT_FOR_RTABMAP',
                               smach_ros.MonitorState('/rtabmap/info', Info, callback_rtabmap_status,
                                                      input_keys=['program'], output_keys=[]),
                               transitions={
                                   'valid': 'WAIT_FOR_RTABMAP',
                                   'invalid': 'WAIT_FOR_PLANNER',
                                   'preempted': 'PREEMPTED_STOP'})

        ########################################  GPS_FIX  ########################################
        # Program callback rtabmap ready
        def callback_gps_status(userdata, msg):
            print("GNSS status: {}".format(msg))
            if sm.preempt_requested():
                sm.service_preempt()
                # sm.recall_preempt()
                return 'preempted'
            if msg.gnss == 'RTK':
                pub_log_info.publish(String("RTK fix aquired"))
                pub_smach_status.publish(String("RTK fix aquired"))
                rospy.sleep(0.5)
                return False
            else:
                return True

        # Add state WAIT_FOR_GPS_FIX
        smach.StateMachine.add('WAIT_FOR_GPS_FIX',
                               smach_ros.MonitorState('/device_state_pub/icon_status', Device_icon_status, callback_gps_status,
                                                      input_keys=[], output_keys=[]),
                               transitions={
                                   'valid': 'WAIT_FOR_GPS_FIX',
                                   'invalid': 'WAIT_FOR_PLANNER',
                                   'preempted': 'PREEMPTED_STOP'})

        ########################################  PLANNER  ########################################
        # Program callback for planner is ready
        def callback_map_status(userdata, msg):
            print("map status: {}".format(msg))
            show_map_planner_pub = rospy.Publisher("/web_plan/show_map_layer", String, latch=True, queue_size=1)
            show_map_planner_pub.publish(String("SMACH|MAP|FULL"))
            if sm.preempt_requested():
                sm.service_preempt()
                sm.recall_preempt()
                return 'preempted'
            if msg.data == userdata.program.map_name:
                pub_log_info.publish(String("Map is ready"))
                pub_smach_status.publish(String("Map ready"))
                pub_pm_play_melody.publish(Int16(1))  # 5:short_beep, 1:beep, 2:double beep,
                rospy.sleep(4)
                return False
            else:
                return True

        # Add state WAIT_FOR_PLANNER
        smach.StateMachine.add('WAIT_FOR_PLANNER',
                               smach_ros.MonitorState('/web_plan/planner_loaded', String, callback_map_status,
                                                      input_keys=['program'], output_keys=[]),
                               transitions={
                                   'valid': 'WAIT_FOR_PLANNER',
                                   'invalid': 'POWER_ON_MOWER',
                                   # 'invalid': 'ZONE_IT',
                                   'preempted': 'PREEMPTED_STOP'})



        ########################################  MOWER  ########################################
        # Add state POWER_ON_MOWER
        @smach.cb_interface(input_keys=[], output_keys=[], outcomes=['success', 'failure'])
        def turn_on_mower_cb(userdata):
            rospy.loginfo('[{}]Turning on mower - state POWER_ON_MOWER'.format(rospy.get_caller_id()))
            pub_mower_set_power = rospy.Publisher('/mower/set_power', Bool, latch=True, queue_size=1)
            msg = Bool()
            msg.data = True
            pub_status = pub_mower_set_power.publish(msg)
            pub_log_info.publish(String("Turn on mower"))
            pub_smach_status.publish(String("Turn on mower"))
            pub_pm_play_melody.publish(Int16(1))  # 5:short_beep, 1:beep, 2:double beep,
            rospy.sleep(2.5)
            if pub_status is None:
                return 'success'

        smach.StateMachine.add('POWER_ON_MOWER', CBState(turn_on_mower_cb),
                               {'success': 'WAIT_FOR_MOWER_ON',
                                'failure': 'POWER_ON_MOWER'})

        # Program callback for mower status WAIT_FOR_MOWER_ON
        def callback_mower_status(userdata, msg):
            if msg.status == 'READY':
                pub_log_info.publish(String("Mower is ready"))
                pub_smach_status.publish(String("Mower ready"))
                pub_pm_play_melody.publish(Int16(1))  # 5:short_beep, 1:beep, 2:double beep,
                rospy.sleep(0.5)
                return False
            else:
                return True

        smach.StateMachine.add('WAIT_FOR_MOWER_ON',
                               smach_ros.MonitorState('/mower/status', Mower, callback_mower_status, output_keys=[]),
                               transitions={
                                   'valid': 'WAIT_FOR_MOWER_ON',
                                   'invalid': 'ZONE_IT',
                                   'preempted': 'PREEMPTED_STOP'})

        ########################################################################################
        ########################################  ZONE  ########################################
        ########################################################################################

        # Iterator for zones
        zone_it = Iterator(outcomes=['succeeded', 'preempted', 'aborted'],
                           input_keys=['program', 'zone_cut_height', 'zone_rpm', 'zone_name', 'zone_start_pose',
                                       'path_plan', 'paths'],
                           it=lambda: range(0, len(sm.userdata.program.zone_list)),
                           output_keys=['zone_cut_height', 'zone_rpm', 'zone_name', 'zone_start_pose', 'path_plan',
                                        'paths'],
                           it_label='index',
                           exhausted_outcome='succeeded')
        zone_it.userdata = sm.userdata
        with zone_it:
            # Create smach state machine for processing zone
            process_zone_sm = smach.StateMachine(outcomes=['succeeded', 'preempted', 'aborted', 'continue'],
                                                 input_keys=['program', 'zone_cut_height', 'zone_rpm', 'index',
                                                             'zone_name', 'zone_start_pose', 'path_plan', 'paths'],
                                                 output_keys=['zone_cut_height', 'zone_rpm', 'zone_name',
                                                              'zone_start_pose', 'path_plan', 'paths'])
            process_zone_sm.userdata = zone_it.userdata

            with process_zone_sm:
                # Add state GET_ZONE_DATA
                smach.StateMachine.add('GET_ZONE_DATA', GetZoneData(),
                                       transitions={'available': 'GET_PATH_TO_START',
                                                    'failed': 'aborted',
                                                    'preempted': 'preempted'})

                # Add state GET_PATH_TO_START - Get path to start point of the zone
                def get_path_result_cb(userdata, status, result):
                    print("get path status: {}".format(status))
                    print("get path result: {}".format(result.message))
                    if process_path_sm.preempt_requested():
                        process_path_sm.service_preempt()
                        return 'preempted'

                    if result.outcome == 2:
                        return 'aborted'
                    else:
                        pub_log_info.publish(String("Go to zone begin"))
                        pub_smach_status.publish(String("Go to zone begin"))
                        pub_pm_play_melody.publish(Int16(2))  # 5:short_beep, 1:beep, 2:double beep,
                        return 'succeeded'

                def get_path_goal_cb(userdata, goal):
                    # print("get path goal: {}".format(goal))
                    wait_for_mbf()

                smach.StateMachine.add('GET_PATH_TO_START', smach_ros.SimpleActionState(
                    '/move_base_flex/get_path', GetPathAction, goal_slots=['target_pose'],
                    result_slots=['path'], goal_cb=get_path_goal_cb, result_cb=get_path_result_cb
                ),
                                       transitions={
                                           'succeeded': 'EXE_PATH_TO_START',
                                           # 'succeeded': 'WAIT_SET_MOTOR_OFF_AND_HOME',
                                           'aborted': 'GET_PATH_TO_START',
                                           'preempted': 'preempted'
                                       },
                                       remapping={
                                           'target_pose': 'zone_start_pose',
                                           'path': 'path_plan'
                                       }
                                       )

                # Add state EXE_PATH_TO_START - Execute path to start point
                def get_exe_result_cb(userdata, status, result):
                    if process_path_sm.preempt_requested():
                        process_path_sm.service_preempt()
                        return 'preempted'
                    if result.outcome == 2:
                        return 'aborted'
                    else:
                        return 'succeeded'

                smach.StateMachine.add('EXE_PATH_TO_START', smach_ros.SimpleActionState(
                    '/move_base_flex/exe_path', ExePathAction, goal_slots=['path'], result_cb=get_exe_result_cb,
                    input_keys=['paths']
                ),
                                       transitions={
                                           'succeeded': 'SET_CUT_HEIGHT',
                                           # 'succeeded': 'PATH_IT',
                                           'aborted': 'RECOVERY',
                                           'preempted': 'preempted'
                                       }, remapping={'path': 'path_plan'}
                                       )

                # Goal callback for state RECOVERY
                def recovery_path_goal_to_start_cb(userdata, goal):
                    pub_log_info = rospy.Publisher('/nextion/log_info', String, queue_size=10, latch=True)
                    pub_log_info.publish(String("Recovery"))

                    goal.behavior = 'clear_costmap'

                # Recovery
                smach.StateMachine.add(
                    'RECOVERY',
                    smach_ros.SimpleActionState(
                        'move_base_flex/recovery',
                        RecoveryAction,
                        goal_cb=recovery_path_goal_to_start_cb,
                        input_keys=["error", "clear_costmap_flag"],
                        output_keys=["error_status", 'clear_costmap_flag']
                    ),
                    transitions={
                        # 'succeeded': 'EXE_PATH_TO_START',
                        'succeeded': 'GET_PATH_TO_START',
                        'aborted': 'GET_PATH_TO_START',
                        'preempted': 'preempted'
                    }
                )


                # Add state SET_CUT_HEIGHT
                @smach.cb_interface(input_keys=['zone_cut_height'], output_keys=[], outcomes=['success', 'failure'])
                def set_height_cb(userdata):
                    rospy.loginfo(
                        '[{}]Setting cut height on mower - state SET_CUT_HEIGHT'.format(rospy.get_caller_id()))
                    pub_mower_set_cut_height = rospy.Publisher('/mower/set_cut_height', Int16, latch=True, queue_size=1)
                    msg = Int16()
                    msg.data = userdata.zone_cut_height
                    pub_status = pub_mower_set_cut_height.publish(msg)
                    pub_log_info.publish(String("Setting mower height"))
                    pub_smach_status.publish(String("Setting height"))
                    pub_pm_play_melody.publish(Int16(1))  # 5:short_beep, 1:beep, 2:double beep,
                    rospy.sleep(1.5)
                    if pub_status is None:
                        return 'success'

                smach.StateMachine.add('SET_CUT_HEIGHT', CBState(set_height_cb),
                                       {'success': 'WAIT_FOR_SET_CUT_HEIGHT', 'failure': 'SET_CUT_HEIGHT'})

                # Callback for mower set cut height WAIT_FOR_SET_CUT_HEIGHT
                def callback_set_cut_height(userdata, msg):
                    if process_path_sm.preempt_requested():
                        process_path_sm.service_preempt()
                        return 'preempted'
                    if msg.status == 'READY':
                        return False
                    else:
                        return True

                smach.StateMachine.add('WAIT_FOR_SET_CUT_HEIGHT',
                                       smach_ros.MonitorState('/mower/status', Mower, callback_set_cut_height,
                                                              output_keys=[], input_keys=['zone_cut_height']),
                                       transitions={
                                           'valid': 'WAIT_FOR_SET_CUT_HEIGHT',
                                           'invalid': 'SET_RPM',
                                           'preempted': 'preempted'})

                # Add state SET_RPM
                @smach.cb_interface(input_keys=['zone_rpm'], output_keys=[], outcomes=['success', 'failure'])
                def set_rpm_cb(userdata):
                    rospy.loginfo(
                        '[{}]Setting motor rpm on mower - state SET_RPM'.format(rospy.get_caller_id()))
                    pub_mower_set_motor_rpm = rospy.Publisher('/mower/set_motor_rpm', Int16, latch=True, queue_size=1)
                    msg = Int16()
                    msg.data = userdata.zone_rpm
                    pub_status = pub_mower_set_motor_rpm.publish(msg)
                    pub_smach_status.publish(String("Set rpm"))
                    if pub_status is None:
                        return 'success'

                smach.StateMachine.add('SET_RPM', CBState(set_rpm_cb),
                                       {'success': 'SET_MOTOR_ON', 'failure': 'SET_RPM'})

                # Add state SET_MOTOR_ON
                @smach.cb_interface(input_keys=[], output_keys=[], outcomes=['success', 'failure'])
                def set_motor_on_cb(userdata):
                    rospy.loginfo(
                        '[{}]Setting mower motor on - state SET_MOTOR_ON'.format(rospy.get_caller_id()))
                    pub_mower_set_motor_on = rospy.Publisher('/mower/set_motor_on', Bool, latch=True, queue_size=1)
                    msg = Bool()
                    msg.data = True
                    pub_status = pub_mower_set_motor_on.publish(msg)

                    if pub_status is None:
                        return 'success'

                smach.StateMachine.add('SET_MOTOR_ON', CBState(set_motor_on_cb),
                                       {'success': 'WAIT_FOR_SET_RPM', 'failure': 'SET_MOTOR_ON'})

                # Callback for mower set cut height WAIT_FOR_SET_RPM
                def callback_set_rpm(userdata, msg):
                    if process_path_sm.preempt_requested():
                        process_path_sm.service_preempt()
                        return 'preempted'
                    if userdata.zone_rpm - 100 < msg.moto_rpm < userdata.zone_rpm + 100:
                        pub_log_info.publish(String("Mowing started..."))
                        pub_smach_status.publish(String("Mowing started"))
                        return False
                    else:
                        return True

                smach.StateMachine.add('WAIT_FOR_SET_RPM',
                                       smach_ros.MonitorState('/mower/status', Mower, callback_set_rpm,
                                                              output_keys=[], input_keys=['zone_rpm']),
                                       transitions={
                                           'valid': 'WAIT_FOR_SET_RPM',
                                           'invalid': 'PATH_IT',
                                           'preempted': 'preempted'})

                ########################################################################################
                #####################################  PATHS  ##########################################
                ########################################################################################

                # Iterate trough paths
                # Provide mowing of paths in zone
                # Iterator for paths
                path_it = Iterator(outcomes=['succeeded', 'preempted', 'aborted'],
                                   input_keys=['program', 'path_plan', 'zone_cut_height', 'zone_rpm',
                                               'zone_name', 'zone_start_pose', 'paths'],
                                   it=lambda: range(0, len(process_zone_sm.userdata.paths)),
                                   output_keys=['path_plan', 'zone_cut_height', 'zone_rpm', 'zone_name',
                                                'zone_start_pose', 'index_path'],
                                   it_label='index_path',
                                   exhausted_outcome='succeeded')
                path_it.userdata = process_zone_sm.userdata

                with path_it:
                    # Create smach state machine for processing path
                    process_path_sm = smach.StateMachine(
                        outcomes=['succeeded_path', 'preempted', 'aborted_path', 'continue_path'],
                        input_keys=['program', 'zone_cut_height', 'zone_rpm', 'index',
                                    'zone_name', 'zone_start_pose', 'path_plan', 'index_path', 'paths'],
                        output_keys=['zone_cut_height', 'zone_rpm', 'zone_name',
                                     'zone_start_pose', 'path_plan'])
                    process_path_sm.userdata = path_it.userdata

                    with process_path_sm:
                        # Add state GET_PATH_DATA
                        smach.StateMachine.add('GET_PATH_DATA', GetPathData(),
                                               transitions={'available': 'GET_PATH_TO_BEGIN_OF_PATH',
                                                            'preempted': 'preempted'})

                        # Add state GET_PATH_TO_BEGIN_OF_PATH - Get path to start point of the zone
                        def get_path_to_path_result_cb(userdata, status, result):
                            print("get path status: {}".format(status))
                            print("get path result.message: {}".format(result.message))
                            print("get path result outcome: {}".format(result.outcome))
                            print("get path result: {}".format(result.cost))
                            # print("get path result: {}".format(result))
                            pub_log_info.publish(String("{}: go to path {}/{}".format(userdata.zone_name, userdata.index_path+1, len(userdata.paths))))
                            pub_smach_status.publish(String("{}: go to path {}/{}".format(userdata.zone_name, userdata.index_path+1, len(userdata.paths))))

                            if process_path_sm.preempt_requested():
                                process_path_sm.service_preempt()
                                return 'preempted'

                            if result.outcome == 0:
                                userdata.path_cost = result.cost
                                return 'succeeded'
                            else:
                                return 'aborted'

                        smach.StateMachine.add('GET_PATH_TO_BEGIN_OF_PATH', smach_ros.SimpleActionState(
                                            '/move_base_flex/get_path', GetPathAction, goal_slots=['target_pose'],
                                            result_slots=['path'], input_keys=['path_start_pose', 'path', 'path_planner', 'path_cost',
                                                                               'zone_name', 'index_path', 'paths'],
                                            output_keys=['path_cost'], result_cb=get_path_to_path_result_cb
                                        ),
                                        transitions={
                                           'succeeded': 'CHECK_DISTANCE',
                                           'aborted': 'GET_PATH_TO_BEGIN_OF_PATH',
                                           'preempted': 'preempted'
                                        },
                                        remapping={
                                           'target_pose': 'path_start_pose',
                                           'path': 'path_plan'
                                        })

                        # Add state CHECK_DISTANCE - check if is on place or not
                        smach.StateMachine.add('CHECK_DISTANCE', CheckDistance(),
                                               transitions={'on_place': 'CHECK_PLANNER_PATH',
                                                            'exe_path': 'EXE_PATH_TO_BEGIN_OF_PATH',
                                                            'preempted': 'preempted'})

                        # Add state EXE_PATH_TO_BEGIN_OF_PATH - Execute path to start point
                        def get_exe_to_path_result_cb(userdata, status, result):
                            print("get path status: {}".format(status))
                            print("get path result: {}".format(result.message))
                            print("get paths: {}".format(len(userdata.paths)))
                            pub_log_info.publish(
                                String("{}: go to path {}/{}".format(userdata.zone_name, userdata.index_path+1, len(userdata.paths))))
                            pub_smach_status.publish(
                                String("{}: go to path {}/{}".format(userdata.zone_name, userdata.index_path+1, len(userdata.paths))))
                            if process_path_sm.preempt_requested():
                                process_path_sm.service_preempt()
                                return 'preempted'
                            if result.outcome == 2:
                                return 'aborted'
                            else:
                                return 'succeeded'

                        smach.StateMachine.add('EXE_PATH_TO_BEGIN_OF_PATH', smach_ros.SimpleActionState(
                            '/move_base_flex/exe_path', ExePathAction, goal_slots=['path'],
                            result_cb=get_exe_to_path_result_cb,
                            input_keys=['paths', 'zone_name', 'index_path', 'zone_name', 'index_path']
                        ),
                                               transitions={
                                                   'succeeded': 'CHECK_PLANNER_PATH',
                                                   'aborted': 'RECOVERY_BEGIN',
                                                   'preempted': 'preempted'
                                               }, remapping={'path': 'path_plan'}
                                               )

                        # Goal callback for state RECOVERY
                        def recovery_path_goal_to_begin_cb(userdata, goal):
                            pub_log_info = rospy.Publisher('/nextion/log_info', String, queue_size=10, latch=True)
                            pub_log_info.publish(String("Recovery"))

                            goal.behavior = 'clear_costmap'

                        # Recovery
                        smach.StateMachine.add(
                            'RECOVERY_BEGIN',
                            smach_ros.SimpleActionState(
                                'move_base_flex/recovery',
                                RecoveryAction,
                                goal_cb=recovery_path_goal_to_begin_cb,
                                input_keys=["error", "clear_costmap_flag"],
                                output_keys=["error_status", 'clear_costmap_flag']
                            ),
                            transitions={
                                'succeeded': 'EXE_PATH_TO_BEGIN_OF_PATH',
                                'aborted': 'GET_PATH_TO_BEGIN_OF_PATH',
                                'preempted': 'preempted'
                            }
                        )


                        # Add state CHECK_PLANNER_PATH - service call to check path
                        @smach.cb_interface(input_keys=['path', 'zone_name', 'index_path', 'paths'])
                        def check_path_request_cb(userdata, request):
                            pub_log_info.publish(
                                String("{}: exe path {}/{}".format(userdata.zone_name, userdata.index_path+1, len(userdata.paths))))
                            pub_smach_status.publish(
                                String("{}: exe path {}/{}".format(userdata.zone_name, userdata.index_path+1, len(userdata.paths))))
                            srvs_request = CheckPathRequest()
                            srvs_request.path = userdata.path
                            srvs_request.safety_dist = 0.1
                            srvs_request.lethal_cost_mult = 0
                            srvs_request.inscrib_cost_mult = 0
                            srvs_request.unknown_cost_mult = 0
                            srvs_request.costmap = CheckPathRequest.GLOBAL_COSTMAP
                            srvs_request.skip_poses = 0
                            srvs_request.use_padded_fp = False
                            srvs_request.path_cells_only = False

                            return srvs_request

                        def check_path_response_cb(userdata, response):
                            print("result: {}".format(response))
                            return 'succeeded'

                        smach.StateMachine.add('CHECK_PLANNER_PATH',
                                               ServiceState('/move_base_flex/check_path_cost',
                                                            CheckPath,
                                                            request_cb=check_path_request_cb,
                                                            response_cb=check_path_response_cb,
                                                            input_keys=['path', 'zone_name', 'index_path', 'paths']),
                                               transitions={'succeeded': 'EXE_PLANNER_PATH',
                                                            'aborted': 'CHECK_PLANNER_PATH',
                                                            'preempted': 'preempted'})

                        # Add state EXE_PLANNER_PATH - Execute path from planner
                        def get_exe_planner_path_result_cb(userdata, status, result):
                            print("exe path status: {}".format(status))
                            print("exe path result: {}".format(result.message))
                            print("exe paths len: {}".format(len(userdata.paths)))
                            print("exe outcome: {}".format(result.outcome))
                            print("exe result: {}".format(result))
                            pub_log_info.publish(
                                String("{}: path {}/{} done".format(userdata.zone_name, userdata.index_path+1, len(userdata.paths))))
                            pub_smach_status.publish(
                                String("{}: path {}/{} done".format(userdata.zone_name, userdata.index_path+1, len(userdata.paths))))
                            if process_path_sm.preempt_requested():
                                process_path_sm.service_preempt()
                                return 'preempted'
                            if result.outcome == 0:
                                return 'succeeded'
                            else:
                                return 'aborted'

                        smach.StateMachine.add('EXE_PLANNER_PATH', smach_ros.SimpleActionState(
                            '/move_base_flex/exe_path', ExePathAction, goal_slots=['path'],
                            result_cb=get_exe_planner_path_result_cb,
                            input_keys=['paths', 'final_pose', 'zone_name', 'index_path']
                        ),
                                               transitions={
                                                   'succeeded': 'continue_path',
                                                   'aborted': 'RECOVERY_PLANNER',
                                                   'preempted': 'preempted'
                                               }, remapping={'path': 'path',
                                                             'final_pose': 'final_pose'}
                                               )

                        # Goal callback for state RECOVERY
                        def recovery_path_goal_to_planner_cb(userdata, goal):
                            pub_log_info = rospy.Publisher('/nextion/log_info', String, queue_size=10, latch=True)
                            pub_log_info.publish(String("Recovery"))

                            goal.behavior = 'clear_costmap'

                        # Recovery
                        smach.StateMachine.add(
                            'RECOVERY_PLANNER',
                            smach_ros.SimpleActionState(
                                'move_base_flex/recovery',
                                RecoveryAction,
                                goal_cb=recovery_path_goal_to_planner_cb,
                                input_keys=["error", "clear_costmap_flag"],
                                output_keys=["error_status", 'clear_costmap_flag']
                            ),
                            transitions={
                                'succeeded': 'EXE_PLANNER_PATH',
                                'aborted': 'CHECK_PLANNER_PATH',
                                'preempted': 'preempted'
                            }
                        )

                    # close processing path
                    Iterator.set_contained_state('PROCESS_PATH', process_path_sm, loop_outcomes=['continue_path'])

                # close Iterator for paths
                smach.StateMachine.add('PATH_IT', path_it,
                                       {'succeeded': 'SET_MOTOR_OFF_AND_HOME', 'aborted': 'aborted'})

                # Add state SET_MOTOR_OFF_AND_HOME
                @smach.cb_interface(input_keys=[], output_keys=[], outcomes=['success', 'failure'])
                def set_motor_off_cb(userdata):
                    rospy.loginfo(
                        '[{}]Setting mower motor on - state SET_MOTOR_OFF_AND_HOME'.format(rospy.get_caller_id()))
                    show_map_planner_pub = rospy.Publisher("/web_plan/show_map_layer", String, latch=True, queue_size=1)
                    show_map_planner_pub.publish(String("SMACH|MAP|FULL"))
                    pub_mower_set_motor_off = rospy.Publisher('/mower/set_home', Bool, latch=True, queue_size=1)
                    msg = Bool()
                    msg.data = True
                    pub_status = pub_mower_set_motor_off.publish(msg)
                    time.sleep(1.5)

                    pub_mower_set_motor_off = rospy.Publisher('/mower/set_motor_on', Bool, latch=True, queue_size=1)
                    msg = Bool()
                    msg.data = False
                    pub_status = pub_mower_set_motor_off.publish(msg)
                    time.sleep(1.5)

                    if pub_status is None:
                        return 'success'

                smach.StateMachine.add('SET_MOTOR_OFF_AND_HOME', CBState(set_motor_off_cb),
                                       {'success': 'WAIT_SET_MOTOR_OFF_AND_HOME', 'failure': 'SET_MOTOR_OFF_AND_HOME'})

                # Callback for mower turn off WAIT_SET_MOTOR_OFF_AND_HOME
                def callback_set_motor_off(userdata, msg):
                    if msg.status == 'READY':
                        return False
                    else:
                        return True

                smach.StateMachine.add('WAIT_SET_MOTOR_OFF_AND_HOME',
                                       smach_ros.MonitorState('/mower/status', Mower, callback_set_motor_off,
                                                              output_keys=[], input_keys=[]),
                                       transitions={
                                           'valid': 'WAIT_SET_MOTOR_OFF_AND_HOME',
                                           'invalid': 'continue',
                                           'preempted': 'preempted'})

            # close processing zone
            Iterator.set_contained_state('PROCESS_ZONE', process_zone_sm, loop_outcomes=['continue'])

        # close Iterator for zones
        smach.StateMachine.add('ZONE_IT', zone_it, {'succeeded': 'POWER_OFF_MOWER', 'aborted': 'aborted', 'preempted': 'PREEMPTED_STOP'})

        # Add state PREEMPTED_STOP
        @smach.cb_interface(input_keys=[], output_keys=[], outcomes=['success', 'failure'])
        def preempted_stop_cb(userdata):
            rospy.loginfo(
                '[{}]Stopping program - state PREEMPTED_STOP'.format(rospy.get_caller_id()))
            pub_log_info.publish(String("Stopping program"))
            pub_smach_status.publish(String("Stopping program"))
            show_map_planner_pub = rospy.Publisher("/web_plan/show_map_layer", String, latch=True, queue_size=1)
            show_map_planner_pub.publish(String("SMACH|MAP|FULL"))
            pub_pm_play_melody.publish(Int16(1))  # 5:short_beep, 1:beep, 2:double beep,
            rospy.sleep(1.5)
            sm.recall_preempt()
            zone_it.recall_preempt()
            process_zone_sm.recall_preempt()
            path_it.recall_preempt()
            process_path_sm.recall_preempt()
            return 'failure'

        smach.StateMachine.add('PREEMPTED_STOP', CBState(preempted_stop_cb),
                               {'success': 'WAIT_MOWER_OFF', 'failure': 'POWER_OFF_MOWER'})

        # Add state POWER_OFF_MOWER
        @smach.cb_interface(input_keys=[], output_keys=[], outcomes=['success', 'failure'])
        def set_mower_off_cb(userdata):
            rospy.loginfo(
                '[{}]Setting mower off - state POWER_OFF_MOWER'.format(rospy.get_caller_id()))
            pub_mower_off = rospy.Publisher('/mower/set_power', Bool, latch=True, queue_size=1)
            msg = Bool()
            msg.data = False
            pub_status = pub_mower_off.publish(msg)
            rospy.sleep(1.5)
            if pub_status is None:
                return 'success'

        smach.StateMachine.add('POWER_OFF_MOWER', CBState(set_mower_off_cb),
                               {'success': 'WAIT_MOWER_OFF', 'failure': 'POWER_OFF_MOWER'})

        # Callback for mower set cut height WAIT_MOWER_OFF
        def callback_set_mower_off(userdata, msg):
            if msg.status == 'OFF':
                # Save program duration
                if userdata.prg_start_time is not None:
                    save_prg_pub = rospy.Publisher("/web_plan/program_new", PlannerProgram, queue_size=1)
                    duration = (rospy.Time.now() - userdata.prg_start_time).to_sec() / 60
                    print("duration: {}".format(duration))
                    userdata.program.last_duration_minutes = int(round(duration))
                    save_prg_pub.publish(userdata.program)
                    userdata.prg_start_time = None


                pub_status = pub_active_prg.publish(String(" "))
                pub_smach_status.publish(String("Ready"))
                pub_log_info.publish(String("Done"))
                return False
            else:
                return True

        smach.StateMachine.add('WAIT_MOWER_OFF',
                               smach_ros.MonitorState('/mower/status', Mower, callback_set_mower_off,
                                                      output_keys=['prg_start_time'], input_keys=['program', 'prg_start_time']),
                               transitions={
                                   'valid': 'WAIT_MOWER_OFF',
                                   'invalid': 'WAIT_FOR_PROGRAM',
                                   'preempted': 'preempted'})

    # Create and start introspection server
    sis = smach_ros.IntrospectionServer('smach_server', sm, '/WAIT_FOR_PROGRAM')
    sis.start()

    def callback_stop(msg):
        if msg.data:
            sm.request_preempt()
            zone_it.request_preempt()
            process_zone_sm.request_preempt()
            path_it.request_preempt()
            process_path_sm.request_preempt()

    rospy.Subscriber("/mower_smach/stop", Bool, callback_stop)

    def signal_handler(sig, frame):
        print("Shutting down...")
        # print(node)
        rospy.signal_shutdown("end")
        sm.request_preempt()
        sis.stop()
        sis.clear()
        time.sleep(1)
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)

    sm.execute()
    rospy.spin()
    sis.stop()


if __name__ == "__main__":
    main()
